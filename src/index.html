<!DOCTYPE html>
<html>
  <head>
    <link
      rel="stylesheet"
      href="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.css"
    />
    <script src="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.js"></script>
  </head>
  <body>
    <div class="ct-chart" />
  </body>

  <script>
    const kaprekarInitial = (limit) => {
      const ret = [];

      //  at least two unique digits
      const valid = (numString) =>
        [...numString].filter((v, i, a) => a.indexOf(v) === i).length >= 2;

      let i = 0;
      while (ret.length < limit) {
        const numString = String(i).padStart(3, "0");

        if (valid(numString)) ret.push(numString);
        i++;
      }

      return ret;
    };

    const constructKaprekarSeries = (initial, length = 10) => {
      const ret = [initial];

      while (ret.length != length) {
        const prev = ret[ret.length - 1];
        const asc = [...prev].sort().join("");
        const desc = [...asc].reverse().join("");

        const newNum = Number(desc) - Number(asc);

        ret.push(String(newNum).padStart(3, "0"));
      }

      return ret;
    };

    const series = kaprekarInitial(15).map((init) =>
      constructKaprekarSeries(init, 20)
    );
    var chart = new Chartist.Line(
      ".ct-chart",
      {
        labels: Array.from({ length: 20 }).map((_, i) => i.toString()),
        series,
      },
      {
        low: 0,
      }
    );

    // Let's put a sequence number aside so we can use it in the event callbacks
    var seq = 0,
      delays = 80,
      durations = 500;

    // Once the chart is fully created we reset the sequence
    chart.on("created", function () {
      seq = 0;
    });

    // On each drawn element by Chartist we use the Chartist.Svg API to trigger SMIL animations
    chart.on("draw", function (data) {
      seq++;

      if (data.type === "line") {
        // If the drawn element is a line we do a simple opacity fade in. This could also be achieved using CSS3 animations.
        data.element.animate({
          opacity: {
            // The delay when we like to start the animation
            begin: seq * delays + 1000,
            // Duration of the animation
            dur: durations,
            // The value where the animation should start
            from: 0,
            // The value where it should end
            to: 1,
          },
        });
      } else if (data.type === "label" && data.axis === "x") {
        data.element.animate({
          y: {
            begin: seq * delays,
            dur: durations,
            from: data.y + 100,
            to: data.y,
            // We can specify an easing function from Chartist.Svg.Easing
            easing: "easeOutQuart",
          },
        });
      } else if (data.type === "label" && data.axis === "y") {
        data.element.animate({
          x: {
            begin: seq * delays,
            dur: durations,
            from: data.x - 100,
            to: data.x,
            easing: "easeOutQuart",
          },
        });
      } else if (data.type === "point") {
        data.element.animate({
          x1: {
            begin: seq * delays,
            dur: durations,
            from: data.x - 10,
            to: data.x,
            easing: "easeOutQuart",
          },
          x2: {
            begin: seq * delays,
            dur: durations,
            from: data.x - 10,
            to: data.x,
            easing: "easeOutQuart",
          },
          opacity: {
            begin: seq * delays,
            dur: durations,
            from: 0,
            to: 1,
            easing: "easeOutQuart",
          },
        });
      } else if (data.type === "grid") {
        // Using data.axis we get x or y which we can use to construct our animation definition objects
        var pos1Animation = {
          begin: seq * delays,
          dur: durations,
          from: data[data.axis.units.pos + "1"] - 30,
          to: data[data.axis.units.pos + "1"],
          easing: "easeOutQuart",
        };
      }
    });
  </script>
</html>
